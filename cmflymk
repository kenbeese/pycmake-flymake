#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Authors:
#   Chen Bin <chenbin DOT sh AT GMAIL>
#   Nil Geisweiller <ngeiswei DOT sh AT GMAIL>
#
# URL: https://github.com/redguartoo/pycmake-flymake
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#   
#   See http://www.gnu.org/copyleft/gpl.html for licence details.

mk_name="Makefile" #or Makefile.flymake?
prog="cmflymk"

import fnmatch,os,re,sys
from optparse import OptionParser

def guess_root_src_dir(build_dir):
    global mk_name
    p1=re.compile("^CMAKE_SOURCE_DIR\s*=(.+)$")
    mkfile=os.path.join(build_dir,mk_name)
    for l in open(mkfile,'r').readlines():
        m=p1.match(l)
        if m:
            src_dir=m.group(1)
            return src_dir.strip()
    return ""

def create_makefile(build_dir,root_src_dir,cm,executable):
    global mk_name
    global prog
    cm_dir=os.path.dirname(cm)
    flag_make=build_dir+cm_dir.replace(root_src_dir,"",1)+"/CMakeFiles/"+executable+".dir/flags.make"
    mk_path=os.path.join(cm_dir,mk_name)
    txt="# Generated by "+prog+". Run '"+prog+" -c' to remove it\n" \
        +"include "+flag_make+"\n" \
        +".PHONY: check-syntax\ncheck-syntax:\n\t${CXX} -o /dev/null ${CXX_FLAGS} ${CXX_DEFINES} -S ${CHK_SOURCES}"

    if options.verbose:
        print mk_path

    f=open(mk_path,"w")
    f.write(txt)
    f.close()

def clean_makefiles():
    global mk_name
    matches = []
    for root, dirnames, filenames in os.walk("."):
        for filename in fnmatch.filter(filenames, 'CMakeLists.txt'):
            matches.append(os.path.join(root, mk_name))

    if options.verbose:
        print "Deleted:"
        
    for f in matches:
        f=os.path.abspath(f)
        if os.path.isfile(f):
            if options.verbose:
                print f
            os.remove(f)

if __name__=="__main__":
    # define options
    usage = "usage: %prog [build_dir] [options]"
    parser = OptionParser(usage)
    parser.add_option("-c", "--clean", action = "store_true", default = False,
                      help = "clean {mk} {program} produced recursively".format(program=prog,mk=mk_name))
    parser.add_option("-v", "--verbose", action = "store_true", default = False,
                      help = "show created/cleaned files")

    #parse options
    (options, args) = parser.parse_args()

    if options.clean:
        clean_makefiles()
        sys.exit()
        
    if len(args) != 1:
        parser.error("incorrect number of arguments. Use --help to get more information")

    build_dir=os.path.abspath(args[0])
    root_src_dir=guess_root_src_dir(build_dir)

    p=re.compile('\s*add_executable\(\s*(\w+)', re.IGNORECASE)
    
    matches = []
    for root, dirnames, filenames in os.walk(root_src_dir):
        for filename in fnmatch.filter(filenames, 'CMakeLists.txt'):
            matches.append(os.path.join(root, filename))
    
    #each cmake file
    if options.verbose:
        print "Created:"
    for cm in matches:
        for l in open(cm,'r').readlines():
            m=p.match(l)
            if m:
                executable=m.group(1)
                create_makefile(build_dir,root_src_dir,cm,executable)
                break

# Local Variables:
# tab-width:4
# indent-tabs-mode:nil
# End:
# vim: set expandtab tabstop=4 shiftwidth=4:
